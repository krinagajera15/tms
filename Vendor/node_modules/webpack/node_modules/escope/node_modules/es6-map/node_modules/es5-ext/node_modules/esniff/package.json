{
  "name": "esniff",
  "version": "2.0.1",
  "description": "Low footprint ECMAScript source code parser",
  "author": {
    "name": "Mariusz Nowak",
    "email": "medyk@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "keywords": [
    "sniff",
    "analyze",
    "ast",
    "parse",
    "syntax",
    "sniffer",
    "detective",
    "detect",
    "find",
    "search",
    "source",
    "code"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/esniff"
  },
  "dependencies": {
    "d": "^1.0.1",
    "es5-ext": "^0.10.62",
    "event-emitter": "^0.3.5",
    "type": "^2.7.2"
  },
  "devDependencies": {
    "eslint": "^8.56.0",
    "eslint-config-medikoo": "^4.2.0",
    "esprima": "^4.0.1",
    "github-release-from-cc-changelog": "^2.3.0",
    "nyc": "^15.1.0",
    "prettier-elastic": "^2.7.1",
    "tad": "^3.1.1"
  },
  "eslintConfig": {
    "extends": "medikoo/es5",
    "root": true,
    "overrides": [
      {
        "files": [
          "index.js"
        ],
        "rules": {
          "max-depth": "off"
        }
      },
      {
        "files": [
          "index.js",
          "utils/is-variable-name.js"
        ],
        "rules": {
          "max-lines": "off"
        }
      },
      {
        "files": [
          "utils/is-variable-name.js"
        ],
        "rules": {
          "no-misleading-character-class": "off"
        }
      },
      {
        "files": [
          "test/**"
        ],
        "env": {
          "node": true
        }
      }
    ]
  },
  "eslintIgnore": [
    "/coverage",
    "/test/__playground"
  ],
  "prettier": {
    "printWidth": 100,
    "tabWidth": 4,
    "overrides": [
      {
        "files": [
          "*.md",
          "*.yml"
        ],
        "options": {
          "tabWidth": 2
        }
      }
    ]
  },
  "nyc": {
    "all": true,
    "exclude": [
      ".github",
      "coverage/**",
      "test/**",
      "*.config.js"
    ],
    "reporter": [
      "lcov",
      "html",
      "text-summary"
    ]
  },
  "scripts": {
    "coverage": "nyc npm test",
    "lint": "eslint .",
    "lint:updated": "pipe-git-updated --base=main --ext=js -- eslint --ignore-pattern '!*'",
    "prettier-check": "prettier -c \"**/*.{css,html,js,json,md,yaml,yml}\"",
    "prettier-check:updated": "pipe-git-updated --base=main --ext=css --ext=html --ext=js --ext=json --ext=md --ext=yaml --ext=yml -- prettier -c",
    "prettify": "prettier --write \"**/*.{css,html,js,json,md,yaml,yml}\"",
    "prettify:updated": "pipe-git-updated ---base=main -ext=css --ext=html --ext=js --ext=json --ext=md --ext=yaml --ext=yml -- prettier --write",
    "test": "node ./node_modules/tad/bin/tad"
  },
  "engines": {
    "node": ">=0.10"
  },
  "license": "ISC",
  "readme": "[![Build status][build-image]][build-url]\n[![Tests coverage][cov-image]][cov-url]\n[![npm version][npm-image]][npm-url]\n\n# esniff\n\n## Low footprint JavaScript source code parser\n\nLow footprint, fast source code parser, which allows you to find all code fragment occurrences with respect to all syntax rules that cannot be handled with plain regular expression search.\n\nIt aims at use cases where we don't need full AST tree, but instead we're interested in finding usages of given function, property etc. in syntactically valid code.\n\n### Installation\n\n#### npm\n\n    $ npm install esniff\n\n### Usage\n\nUsing main module you can configure sophisticated parser on your own. However, first, **see preprared [API utilities](#API) that may already address use cases you have**.\n\n#### esniff(code, executor)\n\n- `code` - Code to parse\n- `executor` - A function to be executed immediately by the constructor, It receives an `emitter` parameter.\n\n`emitter` emits following events:\n\n- `trigger:<char>` - When char is a code character approached in code, that is not a whitespaces, is not in a middle of identificator, is not part of a comment, string, template string or regular expression.\n\nEmitter passes to listener and `accessor` object, which provides access to current parser state and allows to manipulate parsing process. `accessor` exposes following methods:\n\n- `skipCodePart(codePart)` - Skips forward through input _codePart_ assuming parser index points start of given part. Returns true if given `codePart` was found and index and skipped\n- `skipIdentifier` - Skips approached identifier (can be function name or property name), returns `{ name, start, end }` meta object\n- `skipWhitespace` - Skips any whitespace and comments founds at current parsing index\n- `collectScope` - If at current index `(` character is found, it registers given paranthesis scope for registrations (it's content will be returned as one of the results after finished parsing)\n- `stop` - Stops parsing process\n- `index` - Returns currently parsed index\n- `previousToken` - Previous non-whitespace character\n- `scopeDepth` - Current scope depth\n- `shouldCollectComments` - Whether data about code comments should be collected in the result\n\n##### Example\n\nParse all `require(..)` calls:\n\n```javascript\nvar esniff = require(\"esniff\");\n\nvar parseRequires = function (code) {\n  return esniff(code, function (emitter) {\n    emitter.on(\"trigger:r\", function (accessor) {\n      if (accessor.previousToken === \".\") return;\n      if (!accessor.skipCodePart(\"require\")) return;\n      accessor.skipWhitespace();\n      accessor.collectScope();\n    });\n  });\n};\n\nconsole.log(parseRequires(\"var x = require('foo/bar')\"));\n[{ type: \"scope\", point: 17, column: 17, line: 1, raw: \"'foo/bar'\" }];\n```\n\n#### Predefined utils for common use cases\n\n#### accessedProperties(objName) _(esniff/accessed-properties)_\n\nReturns function which allows us to find all accessed property names on given object name\n\n```javascript\nvar findProperties = require(\"esniff/accessed-properties\");\nvar findContextProperties = findProperties(\"this\");\n\nvar result = findContextProperties(\n  \"var foo = \\\"0\\\"; this.bar = foo; this.someMethod(); otherFunction()\"\n);\nconsole.log(result); // [ { name: 'bar', start: 20, end: 23 }, { name: 'someMethod', start: 36, end: 46 } ]\n```\n\n#### function(name[, options]) _(esniff/function)_\n\nReturns function which allows us to find all occurrences of given function (or method) being invoked\n\nThrough options we can restrict cases which we're after:\n\n- `asProperty` (default: `false`), on true will allow `x.name()` when we search for `name` calls\n- `asPlain` (default: `true`), on true it allows plain calls e.g. `name()` when we search for `name`. Should be set to `false` if we're strictly about method calls.\n\nSetting both `asProperty` and `asPlain` to false, will always produce empty result\n\n```javascript\nvar findRequires = require(\"esniff/function\")(\"require\");\n\nfindRequires(\"var x = require('foo/bar')\");\n// [{ point: 17, column: 17, line: 1, raw: '\\'foo/bar\\'' }]\n```\n\n#### resolveArguments(code[, limit]) _(esniff/resolve-arguments)_\n\nResolves expressions separated with commas, with additional `limit` you can specify after which number of arguments resolver should stop\n\n```javascript\nvar resolveArgs = require(\"esniff/resolve-arguments\");\n\nvar result = resolveArgs(\"'raz', 'dwa', ['raz', 'dwa'], 'trzy'\", 3);\n\nconsole.log(result); // ['\"raz\"', ' \"dwa\"', ' [\\'raz\\', \\'dwa\\']']\n```\n\n### Limitations\n\n- _esniff_ assumes code that you pass is syntactically correct, it won't inform you about any syntax errors and may produce unexpected and nonsense results when such code is used.\n- There's single case of syntactically correct code, which will make _esniff_ produce incorrect results, it's division made directly on object literal (e.g. `x = { foo: 'bar' } / 14`, esniff in that case will assume that `/` starts regular expression). Still there's not known use case where such code may make any sense, and many popular JS source code parsers share very same vulnerability.\n\n## Tests\n\n    $ npm test\n\n## Security contact information\n\nTo report a security vulnerability, please use the [Tidelift security contact](https://tidelift.com/security). Tidelift will coordinate the fix and disclosure.\n\n[build-image]: https://github.com/medikoo/esniff/workflows/Integrate/badge.svg\n[build-url]: https://github.com/medikoo/esniff/actions?query=workflow%3AIntegrate\n[cov-image]: https://img.shields.io/codecov/c/github/medikoo/esniff.svg\n[cov-url]: https://codecov.io/gh/medikoo/esniff\n[npm-image]: https://img.shields.io/npm/v/esniff.svg\n[npm-url]: https://www.npmjs.com/package/esniff\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/medikoo/esniff/issues"
  },
  "homepage": "https://github.com/medikoo/esniff",
  "_id": "esniff@2.0.1",
  "_shasum": "a4d4b43a5c71c7ec51c51098c1d8a29081f9b308",
  "_from": "esniff@^2.0.1",
  "_resolved": "https://registry.npmjs.org/esniff/-/esniff-2.0.1.tgz"
}
